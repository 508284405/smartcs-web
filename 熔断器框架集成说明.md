# 熔断器框架集成说明

## 概述

本项目已成功集成 Spring Cloud Circuit Breaker Resilience4j 框架，用于提供统一的熔断器、重试、限流、超时等容错功能。

## 技术栈

- **Spring Cloud Circuit Breaker**: 2024.0.1
- **Resilience4j**: 2.2.0
- **Spring Boot**: 3.4.4

## 配置说明

### 1. 依赖配置

#### 根pom.xml
```xml
<!-- Spring Cloud Circuit Breaker Resilience4j 依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
    <version>${spring-cloud.version}</version>
</dependency>
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot3</artifactId>
    <version>2.2.0</version>
</dependency>
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-micrometer</artifactId>
    <version>2.2.0</version>
</dependency>
```

#### start模块pom.xml
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot3</artifactId>
</dependency>
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-micrometer</artifactId>
</dependency>
```

### 2. 应用配置

#### application.yaml
```yaml
# Resilience4j 熔断器配置
resilience4j:
  circuitbreaker:
    instances:
      redis-memory-store:
        sliding-window-size: 10
        minimum-number-of-calls: 5
        failure-rate-threshold: 50
        wait-duration-in-open-state: 60s
        permitted-number-of-calls-in-half-open-state: 3
        automatic-transition-from-open-to-half-open-enabled: true
        record-exceptions:
          - java.lang.Exception
      id-generator-feign:
        sliding-window-size: 10
        minimum-number-of-calls: 5
        failure-rate-threshold: 50
        wait-duration-in-open-state: 30s
        permitted-number-of-calls-in-half-open-state: 2
        automatic-transition-from-open-to-half-open-enabled: true
      user-center-feign:
        sliding-window-size: 10
        minimum-number-of-calls: 5
        failure-rate-threshold: 50
        wait-duration-in-open-state: 30s
        permitted-number-of-calls-in-half-open-state: 2
        automatic-transition-from-open-to-half-open-enabled: true
      order-feign:
        sliding-window-size: 10
        minimum-number-of-calls: 5
        failure-rate-threshold: 50
        wait-duration-in-open-state: 30s
        permitted-number-of-calls-in-half-open-state: 2
        automatic-transition-from-open-to-half-open-enabled: true
  retry:
    instances:
      redis-memory-store:
        max-attempts: 3
        wait-duration: 1s
        retry-exceptions:
          - java.lang.Exception
      id-generator-feign:
        max-attempts: 2
        wait-duration: 500ms
        retry-exceptions:
          - java.lang.Exception
      user-center-feign:
        max-attempts: 2
        wait-duration: 500ms
        retry-exceptions:
          - java.lang.Exception
      order-feign:
        max-attempts: 2
        wait-duration: 500ms
        retry-exceptions:
          - java.lang.Exception
  ratelimiter:
    instances:
      redis-memory-store:
        limit-for-period: 100
        limit-refresh-period: 1s
        timeout-duration: 5s
      id-generator-feign:
        limit-for-period: 50
        limit-refresh-period: 1s
        timeout-duration: 3s
      user-center-feign:
        limit-for-period: 50
        limit-refresh-period: 1s
        timeout-duration: 3s
      order-feign:
        limit-for-period: 50
        limit-refresh-period: 1s
        timeout-duration: 3s
  timelimiter:
    instances:
      redis-memory-store:
        timeout-duration: 10s
        cancel-running-future: true
      id-generator-feign:
        timeout-duration: 5s
        cancel-running-future: true
      user-center-feign:
        timeout-duration: 5s
        cancel-running-future: true
      order-feign:
        timeout-duration: 5s
        cancel-running-future: true
  bulkhead:
    instances:
      redis-memory-store:
        max-concurrent-calls: 20
        max-wait-duration: 5s
      id-generator-feign:
        max-concurrent-calls: 10
        max-wait-duration: 3s
      user-center-feign:
        max-concurrent-calls: 10
        max-wait-duration: 3s
      order-feign:
        max-concurrent-calls: 10
        max-wait-duration: 3s
```

## 使用方式

### 1. 注解方式使用

#### 熔断器注解
```java
@CircuitBreaker(name = "redis-memory-store", fallbackMethod = "getMessagesFallback")
public List<ChatMessage> getMessages(Object memoryId) {
    return redisChatMemoryStore.getMessages(memoryId);
}

public List<ChatMessage> getMessagesFallback(Object memoryId, Exception e) {
    return fallbackStore.getMessages(memoryId);
}
```

#### 重试注解
```java
@Retry(name = "redis-memory-store", fallbackMethod = "getMessagesFallback")
public List<ChatMessage> getMessages(Object memoryId) {
    return redisChatMemoryStore.getMessages(memoryId);
}
```

#### 限流注解
```java
@Bulkhead(name = "redis-memory-store", fallbackMethod = "getMessagesFallback")
public List<ChatMessage> getMessages(Object memoryId) {
    return redisChatMemoryStore.getMessages(memoryId);
}
```

#### 超时注解
```java
@TimeLimiter(name = "redis-memory-store", fallbackMethod = "getMessagesFallback")
public CompletableFuture<List<ChatMessage>> getMessagesAsync(Object memoryId) {
    return CompletableFuture.supplyAsync(() -> 
        redisChatMemoryStore.getMessages(memoryId));
}
```

### 2. 组合使用

可以同时使用多个注解：
```java
@CircuitBreaker(name = "redis-memory-store", fallbackMethod = "getMessagesFallback")
@Retry(name = "redis-memory-store", fallbackMethod = "getMessagesFallback")
@Bulkhead(name = "redis-memory-store", fallbackMethod = "getMessagesFallback")
@TimeLimiter(name = "redis-memory-store", fallbackMethod = "getMessagesFallback")
public List<ChatMessage> getMessages(Object memoryId) {
    return redisChatMemoryStore.getMessages(memoryId);
}
```

## 监控和指标

### 1. 健康检查

访问 `/actuator/health` 端点可以查看熔断器健康状态。

### 2. 指标监控

访问 `/actuator/metrics` 端点可以查看熔断器相关指标：

- `resilience4j.circuitbreaker.state`: 熔断器状态
- `resilience4j.circuitbreaker.failure_rate`: 失败率
- `resilience4j.circuitbreaker.slow_call_rate`: 慢调用率
- `resilience4j.circuitbreaker.total_calls`: 总调用次数
- `resilience4j.circuitbreaker.failed_calls`: 失败调用次数
- `resilience4j.circuitbreaker.successful_calls`: 成功调用次数

### 3. Prometheus监控

配置了Prometheus指标导出，可以通过Prometheus收集熔断器指标。

## 已集成的组件

### 1. Redis存储熔断器
- **文件**: `FaultTolerantRedisChatMemoryStore.java`
- **功能**: Redis存储的容错处理
- **降级策略**: 降级到内存存储

### 2. Feign客户端熔断器
- **文件**: `IdGeneratorFeignClient.java`, `UserCenterClient.java`
- **功能**: 外部服务调用的容错处理
- **降级策略**: 返回默认值或空结果

### 3. Gateway层熔断器
- **文件**: `IdGeneratorGatewayImpl.java`
- **功能**: 网关层的容错处理
- **降级策略**: 返回基于时间戳的ID

## 测试

### 1. 单元测试
- **文件**: `CircuitBreakerTest.java`
- **功能**: 测试熔断器配置、状态转换、指标收集等

### 2. 集成测试
- **功能**: 测试熔断器在实际环境中的表现

## 最佳实践

### 1. 配置原则
- 根据服务特性调整熔断器参数
- 合理设置失败率阈值和重试次数
- 配置合适的超时时间

### 2. 降级策略
- 提供有意义的降级响应
- 避免在降级方法中执行复杂逻辑
- 记录降级事件用于问题排查

### 3. 监控告警
- 设置熔断器状态告警
- 监控失败率和响应时间
- 定期检查熔断器配置

### 4. 性能考虑
- 避免在降级方法中执行耗时操作
- 合理使用限流和超时
- 监控熔断器对性能的影响

## 故障排查

### 1. 常见问题
- 熔断器未生效：检查注解配置和依赖
- 降级方法不执行：检查方法签名和异常类型
- 指标不准确：检查监控配置

### 2. 调试方法
- 启用Resilience4j调试日志
- 查看熔断器状态和指标
- 检查健康检查端点

## 总结

通过集成Resilience4j框架，项目获得了统一的容错能力，提高了系统的稳定性和可靠性。熔断器、重试、限流、超时等功能的组合使用，为系统提供了多层次的保护机制。 