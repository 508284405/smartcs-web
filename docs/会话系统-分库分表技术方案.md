# 会话系统分库分表技术方案（ShardingSphere-JDBC）

本文档沉淀了对当前“会话系统（Chat Session）”的现状分析、分库分表的方案设计、ShardingSphere‑JDBC 框架研究要点、集成与改造细节、运维与扩容建议，以及测试与风险控制要点，供设计评审与落地实施参考。

---

## 一、背景与目标

- 背景
  - 认证会话使用无状态 JWT（`TokenValidateFilter`），不依赖 HttpSession/Server Session。
  - 业务会话（聊天会话）由领域模型 `Session` 表示，持久化在 `t_cs_session`，消息在 `t_cs_message`。
  - 当前采用 MyBatis‑Plus + MySQL 单库单表，存在读写扩展与热点风险。

- 目标
  - 通过分库分表实现水平扩展、提升吞吐与数据容量上限。
  - 优先保证按 `session_id` 的单分片路由与写入性能，同时兼顾按 `customer_id` 的高频查询。
  - 与现有 DDD + COLA 分层保持一致，改造范围可控、对上层业务透明。

---

## 二、现状梳理

- 主要代码与表结构
  - 领域模型：`smartcs-web-domain/src/main/java/com/leyue/smartcs/domain/chat/Session.java`
  - 应用服务：`smartcs-web-app/src/main/java/com/leyue/smartcs/chat/serviceimpl/SessionServiceImpl.java`
  - 网关实现：`smartcs-web-infrastructure/src/main/java/com/leyue/smartcs/chat/SessionGatewayImpl.java`
  - Mapper XML：`smartcs-web-infrastructure/src/main/resources/mapper/chat/CsSessionMapper.xml`
  - 表结构：
    - 会话：`smartcs-web-infrastructure/src/main/resources/sql/modules/chat/02_cs_session.sql`
    - 消息：`smartcs-web-infrastructure/src/main/resources/sql/modules/chat/03_cs_message.sql`
  - ID 生成：`smartcs-web-infrastructure/src/main/java/com/leyue/smartcs/common/gateway/IdGeneratorGatewayImpl.java`

- 访问特征
  - 写入/更新以 `session_id` 为主（创建、分配、关闭、状态更新）。
  - 查询既有 `session_id` 定位，也有 `customer_id`/`agent_id` 的列表查询与分页。

---

## 三、框架研究（ShardingSphere‑JDBC）

- 能力要点
  - 支持分库分表、读写分离、分布式主键、绑定表、广播表、自定义分片算法（含复合分片）。
  - 以 JDBC 代理方式透明接入，Spring Boot Starter 自动装配，配置简单。
  - 事务提供本地/柔性方案，强一致跨分片需慎用与降级设计。

- 关键特性应用
  - 复合分片算法（Complex）：可同时考虑多个列（本方案使用 `session_id` 与 `customer_id`）。
  - 绑定表（Binding Tables）：保证同一组表在分片维度上同路由，避免 JOIN 路由不一致。

---

## 四、方案设计

### 4.1 分片键与拓扑

- 主分片键：`session_id`（业务全局唯一，由外部 ID 服务生成）。
- 辅助分片键：`customer_id`（提升客户维度查询命中率）。
- 拓扑：2 库 × 4 表（示例，可按流量扩展）。
  - 数据库：`ds_0`、`ds_1`（物理库示例：`smartcs_0`、`smartcs_1`）。
  - 表：`t_cs_session_0..3`，`t_cs_message_0..3`。

### 4.2 路由策略

- 复合分片优先级：`session_id` > `customer_id` > 广播。
- 路由表达：
  - 库：`ds_${session_id % 2}` 或 `ds_${customer_id % 2}`。
  - 表：`t_cs_session_${session_id % 4}`/`t_cs_message_${session_id % 4}`（或以 `customer_id % 4` 兜底）。

### 4.3 绑定表

- 绑定组：`t_cs_session` 与 `t_cs_message`。
- 目的：保持 JOIN/子查询同分片路由，避免跨分片不一致与性能问题。

### 4.4 主键策略

- `id`：各物理表内自增/雪花即可，不作为路由键。
- `session_id`：外部 ID 服务保证全局唯一，作为业务键与路由键。

---

## 五、集成与改造

### 5.1 依赖与配置

- 依赖
  - `start/pom.xml` 增加：
    ```xml
    <dependency>
      <groupId>org.apache.shardingsphere</groupId>
      <artifactId>shardingsphere-jdbc-core-spring-boot-starter</artifactId>
      <version>5.5.1</version>
    </dependency>
    ```

- 配置
  - 新增 `start/src/main/resources/application-sharding.yaml`，核心内容：
    - 两个数据源 `ds_0/ds_1`
    - 绑定表：`t_cs_session,t_cs_message`
    - 两张逻辑表的分片定义（2×4）
    - 复合分片算法（CLASS_BASED）

### 5.2 自定义复合分片算法

- 数据库分片算法：
  - `smartcs-web-infrastructure/src/main/java/com/leyue/smartcs/config/sharding/SessionOrCustomerDatabaseShardingAlgorithm.java`
- 表分片算法：
  - `smartcs-web-infrastructure/src/main/java/com/leyue/smartcs/config/sharding/SessionOrCustomerTableShardingAlgorithm.java`
- 行为：
  - 优先按 `session_id` 取模；无则按 `customer_id`；仍无则广播。

### 5.3 路由安全改造（关键）

- 网关更新使用 `session_id` 条件，避免跨分片广播更新：
  - `smartcs-web-infrastructure/src/main/java/com/leyue/smartcs/chat/SessionGatewayImpl.java`
    - `updateSession(...)` 改为 `where session_id = ?`
    - `updateSessionStatus(...)`、`assignAgent(...)`、`closeSession(...)` 均改为 `LambdaUpdateWrapper` + `session_id`

### 5.4 物理表 DDL

- 会话分表：`smartcs-web-infrastructure/src/main/resources/sql/modules/chat/02_cs_session_shards.sql`
- 消息分表：`smartcs-web-infrastructure/src/main/resources/sql/modules/chat/03_cs_message_shards.sql`
- SQL 指南：`smartcs-web-infrastructure/src/main/resources/sql/README.md`

---

## 六、部署与启用

1) 准备数据库

- 创建物理库：`smartcs_0`、`smartcs_1`。
- 在两个库内分别执行：
  - `modules/chat/02_cs_session_shards.sql`
  - `modules/chat/03_cs_message_shards.sql`

2) 启动配置

- 本地：`cd start && mvn spring-boot:run -Dspring-boot.run.profiles=sharding`
- 生产：将 `application-sharding.yaml` 内容合并至 Nacos 的 `smartcs-web.yaml`。

3) 校验

- 开启 `sql-show: true`，观察路由命中 `ds_x.t_cs_session_y / t_cs_message_y`。
- 场景校验：
  - 创建会话：按 `session_id` 路由单分片写入。
  - 分配/关闭：更新命中单分片（基于 `session_id`）。
  - 客户会话列表：按 `customer_id` 命中对应分片；无键时可能广播。

---

## 七、测试与验证

- 建议用例
  - 路由正确性：以不同 `session_id`/`customer_id` 样本覆盖 0..1 库、0..3 表。
  - 绑定表一致性：`JOIN t_cs_session s JOIN t_cs_message m ON s.session_id = m.session_id` 路由一致。
  - 广播查询观测：无键查询的路由数量，评估可接受范围。

- 集成测试（可选）
  - 使用 Testcontainers 启动 2 个 MySQL 容器 + 初始化分表 DDL，验证路由与 CRUD 正确性（如需我可新增示例）。

---

## 八、风险与对策

- 广播/全路由查询
  - 风险：以 `customer_id/agent_id` 分页且无路由键时会广播，影响延迟与吞吐。
  - 对策：
    - 尽量补齐 `session_id` 或 `customer_id`；
    - 视压测增“客户‑会话”二级索引表/缓存；
    - 考虑复合算法升级（如权重、哈希一致性）与读缓存隔离。

- 扩容与迁移
  - 风险：取模表达式变更需搬迁数据。
  - 对策：
    - 预留足够分片数；
    - 使用离线迁移/双写灰度方案，分批切换；
    - 引入一致性哈希算法以降迁移成本（需自定义）。

- 事务与一致性
  - 风险：跨分片强一致事务复杂且影响性能。
  - 对策：
    - 聚合内写操作尽量单分片完成；
    - 避免跨分片强一致写；必要时柔性事务 + 业务补偿。

- 唯一约束
  - 说明：`uk_session_id` 为物理表内唯一，非全局唯一约束。
  - 对策：外部分布式 ID 服务保障全局唯一；上线前专门压测与巡检。

---

## 九、运维与扩展

- 监控与观察
  - 打开 `sql-show` 与慢 SQL 日志，关注广播比例与热点分片。
  - 指标：每分片 QPS、命中率、P90/P99 延迟、失败率、连接池指标。

- 扩容步骤（示例）
  1) 评估分片热点与容量；
  2) 新建库/表，预热连接；
  3) 数据迁移/双写灰度；
  4) 切换路由规则；
  5) 回滚预案与回填校验。

---

## 十、附录

### A. Sharding 配置片段（示例）

参见：`start/src/main/resources/application-sharding.yaml`

要点：

```yaml
spring:
  shardingsphere:
    props:
      sql-show: true
    datasource:
      names: ds_0, ds_1
      ds_0: { ... }
      ds_1: { ... }
    rules:
      sharding:
        binding-tables:
          - t_cs_session,t_cs_message
        tables:
          t_cs_session:
            actual-data-nodes: ds_${0..1}.t_cs_session_${0..3}
            database-strategy:
              complex:
                sharding-columns: session_id,customer_id
                sharding-algorithm-name: db-composite
            table-strategy:
              complex:
                sharding-columns: session_id,customer_id
                sharding-algorithm-name: tbl-composite
          t_cs_message:
            actual-data-nodes: ds_${0..1}.t_cs_message_${0..3}
            database-strategy:
              complex:
                sharding-columns: session_id,customer_id
                sharding-algorithm-name: db-composite
            table-strategy:
              complex:
                sharding-columns: session_id,customer_id
                sharding-algorithm-name: tbl-composite
        sharding-algorithms:
          db-composite:
            type: CLASS_BASED
            props:
              strategy: COMPLEX
              algorithmClassName: com.leyue.smartcs.config.sharding.SessionOrCustomerDatabaseShardingAlgorithm
              databaseShards: 2
              dsPrefix: ds_
          tbl-composite:
            type: CLASS_BASED
            props:
              strategy: COMPLEX
              algorithmClassName: com.leyue.smartcs.config.sharding.SessionOrCustomerTableShardingAlgorithm
              tableShards: 4
```

### B. 分表 DDL 脚本

- 会话分表：`smartcs-web-infrastructure/src/main/resources/sql/modules/chat/02_cs_session_shards.sql`
- 消息分表：`smartcs-web-infrastructure/src/main/resources/sql/modules/chat/03_cs_message_shards.sql`

### C. 代码改造清单

- 网关路由更新：`smartcs-web-infrastructure/src/main/java/com/leyue/smartcs/chat/SessionGatewayImpl.java`
- 自定义算法：
  - `SessionOrCustomerDatabaseShardingAlgorithm`
  - `SessionOrCustomerTableShardingAlgorithm`
- Sharding 依赖与配置：
  - `start/pom.xml`
  - `start/src/main/resources/application-sharding.yaml`

---

## 总结

本方案以 `session_id` 为主分片键、`customer_id` 为辅，借助 ShardingSphere‑JDBC 的复合分片与绑定表能力，在尽量减少业务侵入的同时实现了会话与消息的水平扩展。通过对网关更新路径的路由约束（统一以 `session_id` 更新）与完善的 DDL/配置指引，方案具备良好的可落地性与可运维性。后续可根据压测结果迭代复合算法与缓存/索引策略，以进一步降低广播查询比例与分片热点。

